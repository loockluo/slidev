---
sidebar_position: 4
title: "ğŸ¤ äººæœºäº¤äº’"
---
# ğŸ¤ äººæœºäº¤äº’

åœ¨ AI åº”ç”¨å¼€å‘ä¸­ï¼Œå®Œå…¨è‡ªåŠ¨åŒ–çš„ç³»ç»Ÿå¹¶ä¸æ€»æ˜¯æœ€ä½³é€‰æ‹©ã€‚æœ‰æ—¶æˆ‘ä»¬éœ€è¦åœ¨å…³é”®å†³ç­–ç‚¹å¼•å…¥äººå·¥å¹²é¢„ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯é æ€§å’Œå‡†ç¡®æ€§ã€‚LangGraphJS çš„äººæœºäº¤äº’åŠŸèƒ½è®©ä½ èƒ½å¤Ÿåœ¨å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­æš‚åœï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼Œç„¶ååŸºäºç”¨æˆ·çš„åé¦ˆç»§ç»­æ‰§è¡Œã€‚

## å¼•è¨€

äººæœºäº¤äº’ï¼ˆHuman-in-the-Loopï¼‰æ˜¯ç°ä»£ AI åº”ç”¨çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦é«˜å‡†ç¡®æ€§å’Œå¯æ§æ€§çš„åœºæ™¯ä¸­ã€‚å°±åƒå‰ç«¯å¼€å‘ä¸­æˆ‘ä»¬éœ€è¦å¤„ç†ç”¨æˆ·çš„ç‚¹å‡»ã€è¾“å…¥å’Œç¡®è®¤æ“ä½œä¸€æ ·ï¼ŒAI åº”ç”¨ä¹Ÿéœ€è¦åœ¨é€‚å½“çš„æ—¶å€™"è¯¢é—®"ç”¨æˆ·çš„æ„è§ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦äººæœºäº¤äº’ï¼Ÿ

åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸é‡åˆ°éœ€è¦ç”¨æˆ·ç¡®è®¤çš„åœºæ™¯ï¼š

- åˆ é™¤é‡è¦æ•°æ®å‰çš„ç¡®è®¤å¯¹è¯æ¡†
- è¡¨å•æäº¤å‰çš„æ•°æ®éªŒè¯
- å¤æ‚æ“ä½œçš„åˆ†æ­¥å¼•å¯¼

åŒæ ·ï¼Œåœ¨ AI åº”ç”¨ä¸­ï¼Œäººæœºäº¤äº’è§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š

- **å‡†ç¡®æ€§ä¿éšœ**ï¼šLLM å¯èƒ½äº§ç”Ÿä¸å‡†ç¡®çš„è¾“å‡ºï¼Œéœ€è¦äººå·¥éªŒè¯
- **å®‰å…¨æ€§æ§åˆ¶**ï¼šæ•æ„Ÿæ“ä½œéœ€è¦äººå·¥å®¡æ‰¹
- **ç”¨æˆ·ä½“éªŒ**ï¼šè®©ç”¨æˆ·å‚ä¸å†³ç­–è¿‡ç¨‹ï¼Œæé«˜ä¿¡ä»»åº¦
- **çµæ´»æ€§**ï¼šæ ¹æ®å…·ä½“æƒ…å†µè°ƒæ•´æ‰§è¡Œè·¯å¾„

## æ ¸å¿ƒæ¦‚å¿µ

### interrupt å‡½æ•°

`interrupt` å‡½æ•°æ˜¯ LangGraphJS ä¸­å®ç°äººæœºäº¤äº’çš„æ ¸å¿ƒå·¥å…·ã€‚å®ƒçš„å·¥ä½œåŸç†ç±»ä¼¼äºå‰ç«¯å¼€å‘ä¸­çš„ `await` æ“ä½œï¼Œä¼šæš‚åœå½“å‰æ‰§è¡Œæµç¨‹ï¼Œç­‰å¾…å¤–éƒ¨è¾“å…¥ã€‚

```mermaid
graph TD
    A[å¼€å§‹æ‰§è¡ŒèŠ‚ç‚¹] --> B[æ‰§è¡Œåˆ° interrupt]
    B --> C[æš‚åœå›¾æ‰§è¡Œ]
    C --> D[ç­‰å¾…ç”¨æˆ·è¾“å…¥]
    D --> E[ç”¨æˆ·æä¾›è¾“å…¥]
    E --> F[ä½¿ç”¨ Command æ¢å¤]
    F --> G[ç»§ç»­æ‰§è¡ŒèŠ‚ç‚¹]
    G --> H[å®ŒæˆèŠ‚ç‚¹æ‰§è¡Œ]

    classDef default fill:#f2f0ff;
    classDef pause fill:#ffeb3b;
    classDef user fill:#4caf50;
    
    class C,D pause;
    class E user;
```

### åŸºæœ¬ä½¿ç”¨æ–¹å¼

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

// å®šä¹‰çŠ¶æ€
const State = Annotation.Root({
  approved: Annotation<boolean>({ default: () => false }),
});

// èŠ‚ç‚¹ï¼šæš‚åœç­‰å¾…ç”¨æˆ·ç¡®è®¤
async function reviewNode(state: typeof State.State) {
  const userInput = await interrupt({ type: "confirm", message: "ç¡®è®¤ç»§ç»­ï¼Ÿ" });
  return { approved: userInput === true };
}

// æ„å»ºå›¾
const graph = new StateGraph(State).addNode("review", reviewNode).addEdge("__start__", "review");

// å¯ç”¨æ£€æŸ¥ç‚¹ä¸çº¿ç¨‹ ID
const checkpointer = new MemorySaver();
const app = graph.compile({ checkpointer });
const thread = { configurable: { thread_id: "demo-thread" } } as const;

// ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼šè§¦å‘ interrupt å¹¶æš‚åœ
await app.invoke({}, thread);

// æ”¶åˆ°å‰ç«¯ç”¨æˆ·è¾“å…¥åæ¢å¤æ‰§è¡Œ
await app.invoke(new Command({ resume: true }), thread);
```

### æŠ€æœ¯è¦æ±‚

ä½¿ç”¨ `interrupt` åŠŸèƒ½éœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

:::info å¿…è¦æ¡ä»¶

1. **Checkpointer**ï¼šå¿…é¡»é…ç½®æ£€æŸ¥ç‚¹ä¿å­˜å™¨æ¥ä¿å­˜å›¾çŠ¶æ€
2. **Thread ID**ï¼šéœ€è¦ä½¿ç”¨çº¿ç¨‹ ID æ¥æ ‡è¯†ä¼šè¯
3. **Command å¯¹è±¡**ï¼šä½¿ç”¨ `Command` å¯¹è±¡æ¥æ¢å¤æ‰§è¡Œ

:::

## è®¾è®¡æ¨¡å¼

### 1. å®¡æ‰¹æµç¨‹æ¨¡å¼

è¿™æ˜¯æœ€å¸¸è§çš„äººæœºäº¤äº’æ¨¡å¼ï¼Œç”¨æˆ·éœ€è¦æ‰¹å‡†æˆ–æ‹’ç»æŸä¸ªæ“ä½œï¼š

```mermaid
graph TD
    A[AI ç”Ÿæˆå»ºè®®] --> B[äººå·¥å®¡æ ¸èŠ‚ç‚¹]
    B --> C{ç”¨æˆ·å†³ç­–}
    C -->|æ‰¹å‡†| D[æ‰§è¡Œæ“ä½œ]
    C -->|æ‹’ç»| E[å–æ¶ˆæ“ä½œ]
    C -->|ä¿®æ”¹| F[ç¼–è¾‘å»ºè®®]
    F --> B
    D --> G[å®Œæˆ]
    E --> G

    classDef default fill:#f2f0ff;
    classDef decision fill:#ff9800;
    classDef action fill:#4caf50;
    classDef cancel fill:#f44336;
    
    class C decision;
    class D,F action;
    class E cancel;
```

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

type Decision = "approve" | "reject" | "modify";

const State = Annotation.Root({
  draft: Annotation<string>({ default: () => "AI ç”Ÿæˆçš„å»ºè®®" }),
  status: Annotation<Decision | null>({ default: () => null }),
});

async function humanGate(state: typeof State.State) {
  const choice = await interrupt({
    type: "choice",
    question: "æ˜¯å¦æ‰¹å‡†æ­¤æ“ä½œï¼Ÿ",
    options: [
      { id: "approve", label: "æ‰¹å‡†" },
      { id: "reject", label: "æ‹’ç»" },
      { id: "modify", label: "ä¿®æ”¹" },
    ],
    context: state.draft,
  });
  return { status: choice as Decision };
}

function applyDecision(state: typeof State.State) {
  if (state.status === "approve") {
    // æ‰§è¡Œæ‰¹å‡†åçš„åŠ¨ä½œ
  }
  return {};
}

const graph = new StateGraph(State)
  .addNode("humanGate", humanGate)
  .addNode("applyDecision", applyDecision)
  .addEdge("__start__", "humanGate")
  .addEdge("humanGate", "applyDecision");

const app = graph.compile({ checkpointer: new MemorySaver() });
const thread = { configurable: { thread_id: "approval" } } as const;

await app.invoke({}, thread); // æš‚åœç­‰å¾…ç”¨æˆ·é€‰æ‹©
// æ¢å¤æ—¶ä¼ å…¥ç”¨æˆ·é€‰æ‹©ï¼š"approve" | "reject" | "modify"
await app.invoke(new Command({ resume: "approve" }), thread);
```

### 2. å†…å®¹ç¼–è¾‘æ¨¡å¼

å…è®¸ç”¨æˆ·ç¼–è¾‘å’Œå®Œå–„ AI ç”Ÿæˆçš„å†…å®¹ï¼š

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

const State = Annotation.Root({
  content: Annotation<string>({ default: () => "åˆç¨¿å†…å®¹" }),
});

async function editNode(state: typeof State.State) {
  const edited = await interrupt({
    type: "text_edit",
    label: "è¯·ç¼–è¾‘å†…å®¹",
    value: state.content,
  });
  return { content: String(edited) };
}

const app = new StateGraph(State).addNode("edit", editNode).addEdge("__start__", "edit").compile({
  checkpointer: new MemorySaver(),
});
const thread = { configurable: { thread_id: "edit-flow" } } as const;

await app.invoke({}, thread); // æš‚åœç­‰å¾…ç¼–è¾‘
await app.invoke(new Command({ resume: "ä¿®æ”¹åçš„å†…å®¹" }), thread);
```

### 3. å·¥å…·è°ƒç”¨å®¡æ ¸æ¨¡å¼

åœ¨æ‰§è¡Œæ•æ„Ÿçš„å·¥å…·è°ƒç”¨å‰è·å¾—ç”¨æˆ·ç¡®è®¤ï¼š

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

const State = Annotation.Root({
  toolCall: Annotation<{ name: string; args: unknown } | null>({ default: () => null }),
  allow: Annotation<boolean>({ default: () => false }),
});

async function reviewTool(state: typeof State.State) {
  const decision = await interrupt({
    type: "confirm",
    message: `æ˜¯å¦å…è®¸è°ƒç”¨å·¥å…·: ${(state.toolCall?.name) ?? "unknown"}?`,
  });
  return { allow: decision === true };
}

function maybeCallTool(state: typeof State.State) {
  if (state.allow && state.toolCall) {
    // åœ¨æ­¤å¤„è°ƒç”¨å®é™…å·¥å…·
  }
  return {};
}

const graph = new StateGraph(State)
  .addNode("reviewTool", reviewTool)
  .addNode("maybeCallTool", maybeCallTool)
  .addEdge("__start__", "reviewTool")
  .addEdge("reviewTool", "maybeCallTool");

const app = graph.compile({ checkpointer: new MemorySaver() });
const thread = { configurable: { thread_id: "tool-review" } } as const;

await app.invoke({ toolCall: { name: "deleteUser", args: { id: 1 } } }, thread);
await app.invoke(new Command({ resume: true }), thread);
```

### 4. å¤šè½®å¯¹è¯æ¨¡å¼

æ”¯æŒè¿ç»­çš„ç”¨æˆ·äº¤äº’ï¼Œæ„å»ºå¯¹è¯å¼ä½“éªŒï¼š

```mermaid
sequenceDiagram
    participant ç”¨æˆ·
    participant å‰ç«¯
    participant LangGraph
    participant AIåŠ©æ‰‹

    ç”¨æˆ·->>å‰ç«¯: å‘èµ·å¯¹è¯
    å‰ç«¯->>LangGraph: å¯åŠ¨å›¾æ‰§è¡Œ
    
    loop å¤šè½®äº¤äº’
        LangGraph->>AIåŠ©æ‰‹: å¤„ç†å½“å‰è¾“å…¥
        AIåŠ©æ‰‹-->>LangGraph: ç”Ÿæˆå“åº”
        
        alt éœ€è¦æ›´å¤šä¿¡æ¯
            LangGraph->>LangGraph: è§¦å‘ interrupt
            LangGraph-->>å‰ç«¯: è¿”å›é—®é¢˜
            å‰ç«¯-->>ç”¨æˆ·: æ˜¾ç¤ºé—®é¢˜
            ç”¨æˆ·->>å‰ç«¯: æä¾›ç­”æ¡ˆ
            å‰ç«¯->>LangGraph: å‘é€ç­”æ¡ˆ
        else å¯¹è¯å®Œæˆ
            LangGraph-->>å‰ç«¯: è¿”å›æœ€ç»ˆç»“æœ
            å‰ç«¯-->>ç”¨æˆ·: æ˜¾ç¤ºç»“æœ
        end
    end
```

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

type Msg = { role: "user" | "assistant"; content: string };
const State = Annotation.Root({
  messages: Annotation<Msg[]>({ default: () => [] }),
});

async function assistant(state: typeof State.State) {
  const last = state.messages[state.messages.length - 1];
  if (!last || last.role === "assistant") return {};

  // å‡è®¾éœ€è¦æ›´å¤šä¿¡æ¯
  const followup = await interrupt({
    type: "question",
    message: "è¯·æä¾›æ›´å¤šç»†èŠ‚ä»¥ç»§ç»­",
  });
  return { messages: [{ role: "assistant", content: String(followup) }] } as any;
}

const app = new StateGraph(State).addNode("assistant", assistant).addEdge("__start__", "assistant").compile({
  checkpointer: new MemorySaver(),
});
const thread = { configurable: { thread_id: "multi-turn" } } as const;

await app.invoke({ messages: [{ role: "user", content: "å¸®æˆ‘è®¢æœºç¥¨" }] }, thread);
await app.invoke(new Command({ resume: "å‡ºå‘åŸå¸‚æ˜¯ä¸Šæµ·" }), thread);
```

## Command å¯¹è±¡è¯¦è§£

`Command` å¯¹è±¡æ˜¯æ¢å¤å›¾æ‰§è¡Œçš„å…³é”®ï¼Œå®ƒæä¾›äº†å¤šç§æ§åˆ¶é€‰é¡¹ï¼š

### åŸºæœ¬æ¢å¤

```typescript
// ç®€å•æ¢å¤ï¼Œä¼ é€’ç”¨æˆ·è¾“å…¥
await graph.invoke(
  new Command({ resume: userInput }),
  threadConfig
);
```

### çŠ¶æ€æ›´æ–°

```typescript
// æ¢å¤æ—¶åŒæ—¶æ›´æ–°çŠ¶æ€
await graph.invoke(
  new Command({ 
    resume: userInput,
    update: { approved: true, timestamp: Date.now() }
  }),
  threadConfig
);
```

### è·¯å¾„æ§åˆ¶

```typescript
// æ¢å¤æ—¶æŒ‡å®šä¸‹ä¸€ä¸ªèŠ‚ç‚¹
await graph.invoke(
  new Command({ 
    resume: userInput,
    goto: 'specific_node'
  }),
  threadConfig
);
```

## å®è·µæŒ‡å¯¼

### è¾“å…¥éªŒè¯

åœ¨å®é™…åº”ç”¨ä¸­ï¼ŒéªŒè¯ç”¨æˆ·è¾“å…¥æ˜¯å¾ˆé‡è¦çš„ï¼š

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

const State = Annotation.Root({
  age: Annotation<number | null>({ default: () => null }),
});

async function askAge(state: typeof State.State) {
  const input = await interrupt({ type: "text", label: "è¯·è¾“å…¥å¹´é¾„" });
  const n = Number(input);
  if (!Number.isInteger(n) || n <= 0) {
    // å†æ¬¡æ‰“æ–­ï¼Œæç¤ºé”™è¯¯å¹¶è¦æ±‚é‡è¯•
    await interrupt({ type: "info", message: "å¹´é¾„å¿…é¡»ä¸ºæ­£æ•´æ•°ï¼Œè¯·é‡è¯•" });
    return {}; // ä¸‹æ¬¡æ¢å¤å°†ä»èŠ‚ç‚¹å¼€å§‹é‡æ–°æ‰§è¡Œ
  }
  return { age: n };
}

const app = new StateGraph(State).addNode("askAge", askAge).addEdge("__start__", "askAge").compile({
  checkpointer: new MemorySaver(),
});
const thread = { configurable: { thread_id: "validation" } } as const;

await app.invoke({}, thread); // ç¬¬ä¸€æ¬¡ï¼šè¯·æ±‚è¾“å…¥
await app.invoke(new Command({ resume: "abc" }), thread); // é”™è¯¯è¾“å…¥
await app.invoke(new Command({ resume: "28" }), thread); // æ­£ç¡®è¾“å…¥
```

### ä¸å‰ç«¯é›†æˆ

åœ¨ React åº”ç”¨ä¸­é›†æˆäººæœºäº¤äº’åŠŸèƒ½ï¼š

```tsx
import React, { useState } from "react";

type HitlProps = {
  onStart: () => Promise<void>; // å¯åŠ¨å›¾æ‰§è¡Œï¼ˆè§¦å‘ interruptï¼‰
  onResume: (value: unknown) => Promise<void>; // ä½¿ç”¨ Command æ¢å¤
};

export function HitlDemo({ onStart, onResume }: HitlProps) {
  const [pending, setPending] = useState(false);
  const [input, setInput] = useState("");

  return (
    <div>
      <button disabled={pending} onClick={async () => { setPending(true); await onStart(); setPending(false); }}>
        å¯åŠ¨å¹¶ç­‰å¾…ç”¨æˆ·è¾“å…¥
      </button>
      <div style={{ marginTop: 12 }}>
        <input value={input} onChange={(e) => setInput(e.target.value)} placeholder="åœ¨æ­¤è¾“å…¥æ¢å¤å€¼" />
        <button onClick={async () => { await onResume(input); }}>æäº¤æ¢å¤</button>
      </div>
    </div>
  );
}
```

## æœ€ä½³å®è·µ

### 1. é¿å…å‰¯ä½œç”¨é‡å¤æ‰§è¡Œ

:::danger é‡è¦æé†’

å½“å›¾ä» `interrupt` æ¢å¤æ—¶ï¼Œä¼šé‡æ–°æ‰§è¡Œæ•´ä¸ªèŠ‚ç‚¹ã€‚å› æ­¤ï¼Œæœ‰å‰¯ä½œç”¨çš„æ“ä½œï¼ˆå¦‚ API è°ƒç”¨ï¼‰åº”è¯¥æ”¾åœ¨ `interrupt` ä¹‹åã€‚

:::

```typescript
// âŒ é”™è¯¯ï¼šå‰¯ä½œç”¨åœ¨ interrupt ä¹‹å‰
function badNode(state: State) {
  // è¿™ä¸ª API è°ƒç”¨ä¼šåœ¨æ¢å¤æ—¶é‡å¤æ‰§è¡Œ
  await expensiveApiCall();
  
  const userInput = interrupt("è¯·ç¡®è®¤æ“ä½œ");
  return { confirmed: userInput };
}

// âœ… æ­£ç¡®ï¼šå‰¯ä½œç”¨åœ¨ interrupt ä¹‹å
function goodNode(state: State) {
  const userInput = interrupt("è¯·ç¡®è®¤æ“ä½œ");
  
  if (userInput) {
    // åªæœ‰åœ¨ç”¨æˆ·ç¡®è®¤åæ‰æ‰§è¡Œ API è°ƒç”¨
    await expensiveApiCall();
  }
  
  return { confirmed: userInput };
}
```

### 2. åˆç†è®¾è®¡ç”¨æˆ·ä½“éªŒ

- **æ¸…æ™°çš„æç¤ºä¿¡æ¯**ï¼šè®©ç”¨æˆ·æ˜ç¡®çŸ¥é“éœ€è¦åšä»€ä¹ˆ
- **æä¾›ä¸Šä¸‹æ–‡**ï¼šç»™ç”¨æˆ·è¶³å¤Ÿçš„ä¿¡æ¯æ¥åšå†³ç­–
- **æ”¯æŒæ’¤é”€**ï¼šå…è®¸ç”¨æˆ·ä¿®æ”¹ä¹‹å‰çš„å†³å®š
- **è¶…æ—¶å¤„ç†**ï¼šè€ƒè™‘ç”¨æˆ·é•¿æ—¶é—´ä¸å“åº”çš„æƒ…å†µ

### 3. é”™è¯¯å¤„ç†

```typescript
import { Annotation, StateGraph } from "@langchain/langgraph";
import { interrupt, Command } from "@langchain/langgraph";
import { MemorySaver } from "@langchain/langgraph/checkpoint/memory";

const State = Annotation.Root({
  confirmed: Annotation<boolean>({ default: () => false }),
  error: Annotation<string | null>({ default: () => null }),
});

async function guardedNode(state: typeof State.State) {
  try {
    const ok = await interrupt({ type: "confirm", message: "ç»§ç»­å—ï¼Ÿ" });
    if (ok !== true) throw new Error("ç”¨æˆ·æœªç¡®è®¤");
    return { confirmed: true, error: null };
  } catch (e: any) {
    return { error: String(e?.message ?? e) };
  }
}

const app = new StateGraph(State).addNode("guarded", guardedNode).addEdge("__start__", "guarded").compile({
  checkpointer: new MemorySaver(),
});
const thread = { configurable: { thread_id: "errors" } } as const;

await app.invoke({}, thread);
await app.invoke(new Command({ resume: false }), thread);
```

### 4. çŠ¶æ€ç®¡ç†

åˆç†è®¾è®¡çŠ¶æ€ç»“æ„ï¼Œè®°å½•äººæœºäº¤äº’çš„å†å²ï¼š

```typescript
const StateAnnotation = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: messagesStateReducer,
    default: () => [],
  }),
  // è®°å½•ç”¨æˆ·äº¤äº’å†å²
  userInteractions: Annotation<UserInteraction[]>({
    reducer: (state, update) => [...state, ...update],
    default: () => [],
  }),
  // å½“å‰ç­‰å¾…çš„ç”¨æˆ·è¾“å…¥
  pendingUserInput: Annotation<string | null>({
    default: () => null,
  }),
});
```

## å¸¸è§é—®é¢˜

### Q: å¦‚ä½•å¤„ç†ç”¨æˆ·é•¿æ—¶é—´ä¸å“åº”ï¼Ÿ

A: å¯ä»¥åœ¨å®¢æˆ·ç«¯è®¾ç½®è¶…æ—¶æœºåˆ¶ï¼Œæˆ–è€…åœ¨å›¾ä¸­æ·»åŠ è¶…æ—¶èŠ‚ç‚¹ï¼š

```typescript
// å®¢æˆ·ç«¯è¶…æ—¶å¤„ç†
const timeout = setTimeout(() => {
  // å‘é€é»˜è®¤å“åº”æˆ–å–æ¶ˆæ“ä½œ
  graph.invoke(new Command({ resume: "timeout" }), threadConfig);
}, 300000); // 5åˆ†é’Ÿè¶…æ—¶
```

### Q: å¯ä»¥åœ¨ä¸€ä¸ªèŠ‚ç‚¹ä¸­ä½¿ç”¨å¤šä¸ª interrupt å—ï¼Ÿ

A: å¯ä»¥ï¼Œä½†éœ€è¦æ³¨æ„æ‰§è¡Œé¡ºåºã€‚æ¯æ¬¡æ¢å¤æ—¶éƒ½ä¼šä»èŠ‚ç‚¹å¼€å§‹é‡æ–°æ‰§è¡Œï¼Œæ‰€ä»¥è¦ç¡®ä¿ interrupt çš„é¡ºåºä¿æŒä¸€è‡´ã€‚

### Q: å¦‚ä½•åœ¨ interrupt ä¸­ä¼ é€’å¤æ‚æ•°æ®ï¼Ÿ

A: `interrupt` å¯ä»¥æ¥å—ä»»ä½•å¯åºåˆ—åŒ–çš„ JSON æ•°æ®ï¼š

```typescript
const userChoice = interrupt({
  type: "choice",
  question: "è¯·é€‰æ‹©æ“ä½œ",
  options: [
    { id: "approve", label: "æ‰¹å‡†", description: "æ‰¹å‡†æ­¤æ“ä½œ" },
    { id: "reject", label: "æ‹’ç»", description: "æ‹’ç»æ­¤æ“ä½œ" },
    { id: "modify", label: "ä¿®æ”¹", description: "ä¿®æ”¹åæ‰¹å‡†" }
  ],
  context: state.currentOperation
});
```

## å°ç»“ä¸å»¶ä¼¸

äººæœºäº¤äº’æ˜¯æ„å»ºå¯é  AI åº”ç”¨çš„é‡è¦æŠ€æœ¯ã€‚é€šè¿‡ `interrupt` å‡½æ•°å’Œ `Command` å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­çµæ´»åœ°å¼•å…¥äººå·¥å¹²é¢„ï¼Œç¡®ä¿ç³»ç»Ÿçš„å‡†ç¡®æ€§å’Œå¯æ§æ€§ã€‚

å…³é”®è¦ç‚¹ï¼š

- **interrupt å‡½æ•°**ï¼šæš‚åœå›¾æ‰§è¡Œï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥
- **Command å¯¹è±¡**ï¼šæ¢å¤æ‰§è¡Œå¹¶æ§åˆ¶åç»­æµç¨‹
- **è®¾è®¡æ¨¡å¼**ï¼šå®¡æ‰¹ã€ç¼–è¾‘ã€å®¡æ ¸ã€å¯¹è¯ç­‰å¸¸è§æ¨¡å¼
- **æœ€ä½³å®è·µ**ï¼šé¿å…å‰¯ä½œç”¨é‡å¤ã€åˆç†è®¾è®¡ç”¨æˆ·ä½“éªŒ

åœ¨ä¸‹ä¸€èŠ‚æ–­ç‚¹è°ƒè¯•ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨æ–­ç‚¹åŠŸèƒ½æ¥è°ƒè¯•å’Œä¼˜åŒ–å›¾çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œè¿™ä¸äººæœºäº¤äº’åŠŸèƒ½ç›¸è¾…ç›¸æˆï¼Œéƒ½æ˜¯æé«˜å¼€å‘æ•ˆç‡çš„é‡è¦å·¥å…·ã€‚

## ç›¸å…³èµ„æº

- [æŒä¹…åŒ–](./æŒä¹…åŒ–)ï¼šäº†è§£æ£€æŸ¥ç‚¹æœºåˆ¶çš„è¯¦ç»†å®ç°
- [æµå¼å¤„ç†](./æµå¼å¤„ç†)ï¼šå­¦ä¹ å¦‚ä½•å®æ—¶è·å– interrupt äº‹ä»¶ 
