---
sidebar_position: 1
title: "ğŸŒŠ æµå¼å¤„ç†"
description: "æŒæ¡ LangGraphJS çš„æµå¼å¤„ç†èƒ½åŠ›ï¼Œæ„å»ºå®æ—¶å“åº”çš„ AI åº”ç”¨"
---

# ğŸŒŠ æµå¼å¤„ç†

æµå¼å¤„ç†æ˜¯ç°ä»£ AI åº”ç”¨çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼Œå®ƒè®©ç”¨æˆ·èƒ½å¤Ÿå®æ—¶çœ‹åˆ° AI çš„æ€è€ƒå’Œå“åº”è¿‡ç¨‹ï¼Œæå¤§æå‡äº†ç”¨æˆ·ä½“éªŒã€‚

## ä¸ºä»€ä¹ˆè¦ç”¨æµå¼å¤„ç†ï¼Ÿ

- é™ä½æ„ŸçŸ¥å»¶è¿Ÿï¼šå…ˆè¿”å› token/ç‰‡æ®µï¼Œç”¨æˆ·â€œç«‹åˆ»æœ‰åé¦ˆâ€ã€‚
- æå‡å¯ç”¨æ€§ï¼šé•¿æ¨ç†/å¤šå·¥å…·é“¾è·¯å¯å±•ç¤ºè¿›åº¦ä¸å…³é”®èŠ‚ç‚¹ã€‚
- æ¸è¿›å¼å‘ˆç°ï¼šè¾¹ç”Ÿæˆè¾¹æ¸²æŸ“ï¼Œæ‰“å­—æœº/éª¨æ¶å±æ›´é¡ºæ»‘ã€‚
- å¯è§‚æµ‹ä¸è°ƒè¯•ï¼šæš´éœ²èŠ‚ç‚¹äº‹ä»¶ã€é‡è¯•ã€é”™è¯¯ï¼Œå®šä½é—®é¢˜æ›´é«˜æ•ˆã€‚
- æˆæœ¬ä¸å®¹é”™ï¼šæ”¯æŒä¸­æ–­ã€é™é€Ÿã€é™çº§ï¼›æ—©åœæ— æ•ˆè¾“å‡ºèŠ‚çœå¼€é”€ã€‚


## ğŸ”„ æµå¼å¤„ç†æ¨¡å¼

LangGraphJS æä¾›äº†å¤šç§æµå¼å¤„ç†æ¨¡å¼ï¼Œæ¯ç§éƒ½æœ‰ç‰¹å®šçš„ä½¿ç”¨åœºæ™¯ï¼š

```mermaid
graph LR
    A[ç”¨æˆ·è¯·æ±‚] --> B{é€‰æ‹©æµå¼æ¨¡å¼}
    B -->|å®Œæ•´çŠ¶æ€| C[values]
    B -->|çŠ¶æ€æ›´æ–°| D[updates]
    B -->|LLM ä»¤ç‰Œ| E[messages]
    B -->|è‡ªå®šä¹‰æ•°æ®| F[custom]
    B -->|è°ƒè¯•ä¿¡æ¯| G[debug]
    B -->|æ£€æŸ¥ç‚¹| H[checkpoints]
    B -->|ä»»åŠ¡| I[tasks]
    
    C --> R1[å®æ—¶çŠ¶æ€ç›‘æ§]
    D --> R2[å¢é‡æ›´æ–°å¤„ç†]
    E --> R3[æ‰“å­—æœºæ•ˆæœ]
    F --> R4[è‡ªå®šä¹‰ UI æ›´æ–°]
    G --> R5[å¼€å‘è°ƒè¯•]
    H --> R6[æ–­ç‚¹ç»­ä¼ /æ—¶é—´æ—…è¡Œ]
    I --> R7[ä»»åŠ¡ç¼–æ’/ç›‘æ§]
    
    classDef default fill:#f2f0ff;
    classDef mode fill:#e1f5fe;
    classDef result fill:#f3e5f5;
    
    class C,D,E,F,G,H,I mode;
    class R1,R2,R3,R4,R5,R6,R7 result;
```

### ğŸ“‹ æ¨¡å¼å¯¹æ¯”è¡¨ï¼ˆ7 ç§ï¼‰

| æ¨¡å¼ | ç”¨é€” | æ•°æ®å†…å®¹ | é€‚ç”¨åœºæ™¯ |
|------|------|----------|----------|
| `values` | å®Œæ•´çŠ¶æ€æµ | æ¯æ­¥åçš„å®Œæ•´çŠ¶æ€ | çŠ¶æ€ç›‘æ§ã€è¿›åº¦å±•ç¤º |
| `updates` | å¢é‡æ›´æ–°æµ | æ¯æ­¥çš„çŠ¶æ€å˜åŒ– | å®æ—¶æ›´æ–°ã€å·®å¼‚å¤„ç† |
| `messages` | LLM tokenæµ | LLM ç”Ÿæˆçš„token | æ‰“å­—æœºæ•ˆæœã€å®æ—¶èŠå¤© |
| `custom` | è‡ªå®šä¹‰æ•°æ®æµ | èŠ‚ç‚¹å†…è‡ªå®šä¹‰æ•°æ® | ç‰¹æ®Š UI æ›´æ–° |
| `debug` | è°ƒè¯•ä¿¡æ¯æµ | è¯¦ç»†æ‰§è¡Œä¿¡æ¯ | å¼€å‘è°ƒè¯•ã€é—®é¢˜æ’æŸ¥ |
| `checkpoints` | æ£€æŸ¥ç‚¹æµ | æ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ£€æŸ¥ç‚¹ä¿¡æ¯ | æ–­ç‚¹ç»­ä¼ ã€æ—¶é—´æ—…è¡Œ |
| `tasks` | ä»»åŠ¡æµ | èŠ‚ç‚¹/å­å›¾ä»»åŠ¡çº§äº‹ä»¶ | å¤æ‚ç¼–æ’ã€ä»»åŠ¡ç›‘æ§ |

 

## ğŸ›ï¸ ä¸ƒç§æµå¼æ¨¡å¼è¯¦è§£

### Values æ¨¡å¼ - å®Œæ•´çŠ¶æ€æµ

é€‚ç”¨äºéœ€è¦å®Œæ•´çŠ¶æ€ä¿¡æ¯çš„åœºæ™¯ï¼Œå¦‚è¿›åº¦æ¡ã€çŠ¶æ€é¢æ¿ç­‰ï¼š

```typescript
// Values æ¨¡å¼ - è·å–å®Œæ•´çŠ¶æ€
for await (const chunk of await graph.stream(input, { 
  streamMode: "values" 
})) {
  console.log("å®Œæ•´çŠ¶æ€:", chunk);
  // æ›´æ–° UI çŠ¶æ€æ˜¾ç¤º
  updateProgressBar(chunk);
}
```

### Updates æ¨¡å¼ - å¢é‡æ›´æ–°æµ

é€‚ç”¨äºåªå…³å¿ƒå˜åŒ–éƒ¨åˆ†çš„åœºæ™¯ï¼Œå‡å°‘æ•°æ®ä¼ è¾“é‡ï¼š

```typescript
// Updates æ¨¡å¼ - åªè·å–å˜åŒ–
for await (const chunk of await graph.stream(input, { 
  streamMode: "updates" 
})) {
  console.log("çŠ¶æ€æ›´æ–°:", chunk);
  // åªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
  applyIncrementalUpdate(chunk);
}
```

### Messages æ¨¡å¼ - LLM tokenæµ

æœ€å¸¸ç”¨çš„æ¨¡å¼ï¼Œç”¨äºå®ç°æ‰“å­—æœºæ•ˆæœï¼š

```typescript
async function streamMessages(input: { messages: BaseMessage[] }) {
    console.log("\n[messages] æ‰“å­—æœºæ•ˆæœå¼€å§‹");
    for await (const chunk of await graph.stream(input, { streamMode: "messages" })) {
        console.log(chunk?.[0]?.content);
    }
    console.log("\n[messages] ä»¥ä¸Šä¸ºæ‰“å­—æœºæ•ˆæœ");
}

```

### Custom æ¨¡å¼ - è‡ªå®šä¹‰æ•°æ®æµ

ç”¨äºåœ¨èŠ‚ç‚¹å†…éƒ¨ä¸»åŠ¨å‘é€è‡ªå®šä¹‰ç»“æ„çš„æ•°æ®ï¼ˆå¦‚è¿›åº¦ã€æŒ‡æ ‡ã€ç‰‡æ®µç»“æ„åŒ–æ¶ˆæ¯ï¼‰ï¼Œæ–¹ä¾¿å‰ç«¯åšç‰¹æ®Š UI æ›´æ–°ï¼š

```typescript
// Custom æ¨¡å¼ - èŠ‚ç‚¹ä¾§éœ€ä¸»åŠ¨å‘é€è‡ªå®šä¹‰æ•°æ®
for await (const data of await graph.stream(input, { streamMode: "custom" })) {
  console.log("è‡ªå®šä¹‰æ•°æ®:", data);
  // ä¾‹å¦‚: æ ¹æ® data.type åˆ†å‘åˆ°ä¸åŒçš„ UI åŒºåŸŸ
}
```

```ts
const customNode = async (state: typeof StateAnnotation.State, context: any) => {
    // æ¨é€è¿›åº¦ç±»äº‹ä»¶
    context?.writer?.('å¼€å§‹è‡ªå®šä¹‰äº‹ä»¶');

   
    context?.writer?.({type: 'è‡ªå®šä¹‰äº‹ä»¶', data: {}});
    return {  };
};
```


### Debug æ¨¡å¼ - è°ƒè¯•ä¿¡æ¯æµ

è¾“å‡ºèŠ‚ç‚¹è¿›å…¥/é€€å‡ºã€è¾“å…¥/è¾“å‡ºã€é‡è¯•ã€é”™è¯¯ç­‰è¯¦å°½çš„æ‰§è¡Œä¿¡æ¯ï¼Œé€‚åˆå¼€å‘é˜¶æ®µå®šä½é—®é¢˜ï¼š

```typescript
// Debug æ¨¡å¼ - è¯¦ç»†è°ƒè¯•äº‹ä»¶
for await (const dbg of await graph.stream(input, { streamMode: "debug" })) {
  console.log("è°ƒè¯•äº‹ä»¶:", dbg);
  // å¯ç»“åˆ run_idã€node åç§°è¿›è¡Œè¿‡æ»¤ä¸å½’æ¡£
}
```

### Checkpoints æ¨¡å¼ - æ£€æŸ¥ç‚¹æµ

ç”¨äºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­è·å–æ£€æŸ¥ç‚¹ä¿¡æ¯ï¼Œä¾¿äºæ–­ç‚¹ç»­ä¼ æˆ–â€œæ—¶é—´æ—…è¡Œâ€ï¼š

```typescript
// Checkpoints æ¨¡å¼ - è·å–æ£€æŸ¥ç‚¹äº‹ä»¶
for await (const cp of await graph.stream(input, { streamMode: "checkpoints" })) {
  console.log("æ£€æŸ¥ç‚¹:", cp);
  // ä¾‹å¦‚è®°å½• checkpoint_id ä»¥ä¾¿åç»­ resume
}
```

### Tasks æ¨¡å¼ - ä»»åŠ¡æµ

ç”¨äºè§‚å¯Ÿå›¾ä¸­ä»»åŠ¡ï¼ˆèŠ‚ç‚¹/å­å›¾ï¼‰çº§åˆ«çš„å¼€å§‹ã€ç»“æŸä¸çŠ¶æ€ï¼š

```typescript
// Tasks æ¨¡å¼ - ä»»åŠ¡çº§äº‹ä»¶
for await (const task of await graph.stream(input, { streamMode: "tasks" })) {
  console.log("ä»»åŠ¡äº‹ä»¶:", task);
  // å¯ç”¨äºå¯è§†åŒ–æ‰§è¡Œè¿›åº¦æˆ–ä»»åŠ¡ç›‘æ§
}
```

 

 

## ğŸ§· streamEvents ä½¿ç”¨è¯¦è§£

`streamEvents` æä¾›åº•å±‚äº‹ä»¶æµï¼ˆåŒ…å« tokenã€èŠ‚ç‚¹è¿›å‡ºã€å·¥å…·è°ƒç”¨ã€é”™è¯¯ä¸é‡è¯•ç­‰ï¼‰ã€‚é€‚ç”¨äºï¼š
- éœ€è¦â€œæ‰“å­—æœºæ•ˆæœâ€çš„ token çº§å±•ç¤º
- ç²¾ç»†è°ƒè¯•ä¸å¯è§‚æµ‹æ€§ï¼ˆTracing/Telemetryï¼‰
- å¯¹èŠ‚ç‚¹/æ¨¡å‹ç”Ÿå‘½å‘¨æœŸäº‹ä»¶æœ‰ä¾èµ–çš„åœºæ™¯

**æœ€å°ç¤ºä¾‹**

```typescript
for await (const event of graph.streamEvents(input, { version: "v2" })) {
  if (event.event === "on_chat_model_stream") {
    const token = event.data.chunk.content;
    process.stdout.write(String(token));
  }
  // è¿˜å¯ç›‘å¬ï¼šon_tool_start/end, on_chain_start/end, on_chat_model_start/end ç­‰
}
```


**äº‹ä»¶å‘½åä¸åˆ†ç±»è¯´æ˜**

äº‹ä»¶åéµå¾ª `on_[runnable_type]_(start|stream|end)`ï¼Œå…¶ä¸­ï¼š
- runnable_type å–å€¼åŒ…æ‹¬ï¼š
  - `llm`ï¼šéèŠå¤©æ¨¡å‹
  - `chat_model`ï¼šèŠå¤©æ¨¡å‹
  - `prompt`ï¼šå¦‚ `ChatPromptTemplate`
  - `tool`ï¼šLangChain å·¥å…·
  - `chain`ï¼šå¤§å¤šæ•° Runnables å±äºæ­¤ç±»
- äº‹ä»¶é˜¶æ®µï¼ˆcategoryï¼‰ï¼š
  - `start`ï¼šrunnable å¼€å§‹
  - `stream`ï¼šrunnable æµå¼è¿›è¡Œä¸­
  - `end`ï¼šrunnable ç»“æŸ


å¸¸è§ç›‘å¬ç¤ºä¾‹ï¼š
```typescript
for await (const e of graph.streamEvents(input, { version: "v2" })) {
  switch (e.event) {
    case "on_chat_model_start":
      // e.data.input / metadata
      break;
    case "on_chat_model_stream":
      // e.data.chunk.content ä¸ºå¢é‡ token
      break;
    case "on_chat_model_end":
      // e.data.output ä¸ºæ¨¡å‹æœ€ç»ˆè¾“å‡º
      break;
    case "on_tool_start":
    case "on_tool_end":
    case "on_chain_start":
    case "on_chain_end":
      // å¯æŒ‰éœ€åŒºåˆ†å¤„ç†
      break;
  }
}
```

 

 
**ä¸ messages æ¨¡å¼çš„åŒºåˆ«**

- messagesï¼šé«˜å±‚â€œæ¶ˆæ¯å¢é‡â€ï¼Œè½»é‡ã€ç¨³å®šã€é¢å‘ UI å±•ç¤º
- streamEventsï¼šåº•å±‚â€œäº‹ä»¶æ€»çº¿â€ï¼Œç²’åº¦ç»†ã€ä¿¡æ¯å…¨ã€é€‚åˆè°ƒè¯•ä¸åŸ‹ç‚¹



### ğŸ§ª ä¸ƒç§æµå¼æ¨¡å¼å®Œæ•´ç¤ºä¾‹

ä¸‹é¢çš„ç¤ºä¾‹å…ˆæ„å»ºåŒä¸€å¼  `StateGraph`ï¼Œç„¶ååˆ†åˆ«æ¼”ç¤º `values`ã€`updates`ã€`messages`ã€`custom`ã€`debug`ã€`checkpoints`ã€`tasks` ä¸ƒç§æµå¼æ¨¡å¼çš„æ¶ˆè´¹æ–¹å¼ï¼Œä¾¿äºä½ åœ¨å®é™…é¡¹ç›®ä¸­å¿«é€Ÿå¯¹æ¯”å’Œæ›¿æ¢ã€‚

```typescript
 import "./lib/loadEnv";
import { BaseMessage, HumanMessage } from "@langchain/core/messages";
import { Annotation, StateGraph } from "@langchain/langgraph";
import { ChatOpenAI } from "@langchain/openai";

// 1) æ„å»º LLM ä¸çŠ¶æ€çŠ¶æ€
const llm = new ChatOpenAI({ model: "qwen3-max" });

const StateAnnotation = Annotation.Root({
    messages: Annotation<BaseMessage[]>(),
    summary: Annotation<string>(),
});

// 2) å®šä¹‰èŠ‚ç‚¹
const llmNode = async (state: typeof StateAnnotation.State) => {
    const res = await llm.invoke(state.messages);
    return { messages: [res] };
};

const summaryNode = async (state: typeof StateAnnotation.State, context: any) => {
    // æ¨é€è¿›åº¦ç±»äº‹ä»¶
    context?.writer?.('å¼€å§‹æ€»ç»“');

    const summary = await llm.invoke([
        ...state.messages,
        new HumanMessage("è¯·æ€»ç»“ä¸€ä¸‹å‰é¢çš„å¯¹è¯"),
    ]);

    context?.writer?.('ç»“æŸæ€»ç»“');
    return { summary: String(summary.content) };
};

// 3) æ„å»ºå›¾
const graph = new StateGraph(StateAnnotation)
    .addNode("llmNode", llmNode)
    .addNode("summaryNode", summaryNode)
    .addEdge("__start__", "llmNode")
    .addEdge("llmNode", "summaryNode")
    .addEdge("summaryNode", "__end__")
    .compile();

// 4) å°†ä¸ƒç§æ¨¡å¼å°è£…ä¸ºå¯å¤ç”¨å‡½æ•°ï¼Œä¾¿äºåœ¨ä¸‹æ–¹å°èŠ‚ç›´æ¥å¼•ç”¨
async function streamValues(input: { messages: BaseMessage[] }) {
    for await (const chunk of await graph.stream(input, { streamMode: "values" })) {
        console.log("[values] å®Œæ•´çŠ¶æ€:", chunk);
    }
}

async function streamUpdates(input: { messages: BaseMessage[] }) {
    for await (const chunk of await graph.stream(input, { streamMode: "updates" })) {
        console.log("[updates] çŠ¶æ€æ›´æ–°:", chunk);
    }
}

async function streamMessages(input: { messages: BaseMessage[] }) {
    console.log("\n[messages] æ‰“å­—æœºæ•ˆæœå¼€å§‹");
    for await (const chunk of await graph.stream(input, { streamMode: "messages" })) {
        console.log(chunk?.[0]?.content);
    }
    console.log("\n[messages] ä»¥ä¸Šä¸ºæ‰“å­—æœºæ•ˆæœ");
}


async function streamCustom(input: { messages: BaseMessage[] }) {
    for await (const custom of await graph.stream(input, { streamMode: "custom" })) {
        console.log("[custom] è‡ªå®šä¹‰æ•°æ®:", custom);
    }
}

async function streamDebug(input: { messages: BaseMessage[] }) {
    for await (const dbg of await graph.stream(input, { streamMode: "debug" })) {
        console.log("[debug] äº‹ä»¶:", dbg);
    }
}

async function streamCheckpoints(input: { messages: BaseMessage[] }) {
    for await (const cp of await graph.stream(input, { streamMode: "checkpoints" })) {
        console.log("[checkpoints] æ£€æŸ¥ç‚¹:", cp);
    }
}

async function streamTasks(input: { messages: BaseMessage[] }) {
    for await (const task of await graph.stream(input, { streamMode: "tasks" })) {
        console.log("[tasks] ä»»åŠ¡äº‹ä»¶:", task);
    }
}


async function streamEvents(input: { messages: BaseMessage[] }) {
    for await (const e of graph.streamEvents(input, { version: 'v2' })) {
        console.log("[streamEvents] :", e.event);
    }
}

async function runAll() {
    const input = { messages: [new HumanMessage("ä½ å¥½")] };
    await streamUpdates(input);
    await streamValues(input);
    await streamMessages(input);
    await streamCustom(input);
    await streamDebug(input);
    await streamCheckpoints(input);
    await streamTasks(input);

    await streamEvents(input)
}

runAll();
```


## ğŸ”® å°ç»“

æµå¼å¤„ç†æ˜¯ LangGraphJS çš„å¼ºå¤§ç‰¹æ€§ï¼Œå®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå“åº”è¿…é€Ÿã€ç”¨æˆ·ä½“éªŒä¼˜ç§€çš„ AI åº”ç”¨ã€‚é€šè¿‡åˆç†é€‰æ‹©æµå¼æ¨¡å¼ã€ä¼˜åŒ–æ€§èƒ½å’Œå¤„ç†é”™è¯¯ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºå‡ºä¸“ä¸šçº§çš„å®æ—¶ AI åº”ç”¨ã€‚

### å…³é”®è¦ç‚¹å›é¡¾

1. **é€‰æ‹©åˆé€‚çš„æµå¼æ¨¡å¼**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹© valuesã€updatesã€messages ç­‰æ¨¡å¼
2. **ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ**ï¼šä½¿ç”¨ç¼“å†²ã€é˜²æŠ–ç­‰æŠ€æœ¯ä¼˜åŒ– UI å“åº”
3. **å¤„ç†é”™è¯¯æƒ…å†µ**ï¼šå®ç°é‡è¯•ã€é™çº§å’Œæ¢å¤æœºåˆ¶
4. **ç›‘æ§æ€§èƒ½**ï¼šè·Ÿè¸ªæµå¼å¤„ç†çš„æ€§èƒ½æŒ‡æ ‡
 

:::tip å®è·µå»ºè®®

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå»ºè®®ï¼š
1. ä»ç®€å•çš„ messages æ¨¡å¼å¼€å§‹
2. é€æ­¥æ·»åŠ é”™è¯¯å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–
3. æ ¹æ®ç”¨æˆ·åé¦ˆè°ƒæ•´ç¼“å†²å’Œæ›´æ–°ç­–ç•¥
4. ä½¿ç”¨æ€§èƒ½ç›‘æ§å·¥å…·è·Ÿè¸ªæµå¼å¤„ç†æ•ˆæœ

:::
